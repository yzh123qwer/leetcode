# 01
在完成周赛之后，我认为第一个题其实比02,03难。尽管实现比较简单，但是为了避免超时是需要进行一些处理的。首先选出子序列的和是顺序没有关系的，因此对nums数组进行排序是为了更快求出
各个子序列的和的必要操作。然后在遍历queries数组的过程中，queries数组不是有序的，必然会出现根据queries\[i]去寻找对应的最大子序列和，这样在多次寻找遍历中，无疑会消耗大量时间。
这是不好的方法，很有可能发生超时的情况。改进方法是对queries进行数组排列，但是返回答案的数组应该是和原queries数组的顺序一一对应，算法实现中采用了一个哈希表来维持排序后的queries
数组和原queries数组的关系。考虑到queries同一个数可能出现多次，因此哈希表并不只能满足一个数字对应到一个位置，哈希表存储一个值对应到一个链表，链表中存放该值出现过的所有位置。
# 02
这个题就是一个很常规的对栈的应用。创建一个栈sta，依次遍历s中的字符，如果遇到字母则推入栈，遇到\*则将最后一个字母推出，注意推出前判断栈是否为空。
# 03 
这个题同样比较常规，只要理清思路，就可以快速完成。所有3辆车辆都从0号位置出发，即必须从0号走到对应垃圾的最远位置。并且所有垃圾的清理时间都是相同的。
# 04
## 拓扑排序
问题：<br>
在一个有向图中，对所有的节点进行排序，要求没有一个节点指向它前面的节点。<br>
解决方法：<br>
首先引入一个概念入度，即一个节点被其他节点所指的总和，如果一个节点没有被任何节点所指，那么该节点的入度就是0。
拓扑排序是首先统计所有节点的入度，并且将入度为0的节点先分离出来，并将其指向的节点入度减1，重复这一操作，直到所有节点都分离，或者没有入度为0的节点(有向图是存在循环的)。<br>
在该问题中，程序的第一步就是拓扑排序，题意是将一个数对，要求数对的第一个数必须出现在数对的第二个数之前。可以理解为第一个节点指向第二个节点。那么对给出的所有数对进行拓扑
排序之后，如果排序结果小于数目k，即有向图中存在循环，数对中存在矛盾关系。等于k则得到正确的排序结果。<br>
在得到正确的排序结果之后，只要将其按照要求放入二维数组中对应的位置即可。
