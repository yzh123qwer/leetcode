# 01
第一个题简单题，是一个对贪婪算法的简单利用，并且由逻辑就可以非常快速的推断出，贪婪算法就是该题目的最优解。因为一直选两次总是要优于选一次的，只有在最后时刻，
剩下一杯水，才选一次。
# 02
题目中是说，包含无限正整数的集合，因此肯定不能将所用正整数存储在内存中，可以转换为记录删除的数字。程序中使用一个hash表来存储所有删除数字
如果是从删除的数字中添加数字，则从hash表中删除该数字，否则，不进行任何处理。同时需要维护一个当前正整数集合的最小值。<br>
实际上题目中给出的测试用例是1-1000，因此完全可以将1-1000存储在一个数组中，通过下标来表示数字，下标索引访问的值可以使用1表示存在，0表示被删除。
# 03
首先，无论怎么移动，由于 L 和 R 无法互相穿过对方，那么去掉 _ 后的剩余字符应该是相同的，否则返回 false。<br>
如果当前字符为 L 且 i<ji<j，那么这个 L 由于无法向右移动，返回 false；<br>
如果当前字符为 R 且 i>ji>j，那么这个 R 由于无法向左移动，返回 false。<br>
遍历完，若中途没有返回 false 就返回 true。<br>
程序中记录位置，是通过一个栈来记录的，并且使用一个数组来维护每个字符能够移动的位置，实际上有更好方式。<br>
更好的方式就是使用双指针。
