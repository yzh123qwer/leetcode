# kmp算法
kmp算法需要先找出字符最大相同前后缀，这里数学推动较为复杂，给出求解方法<br>
设定 \pi(i)=j+1π(i)=j+1，jj 的初始值为 \pi(i-1)π(i−1)。我们只需要不断迭代 jj（令 jj 变为 \pi(j-1)π(j−1)）直到 s[i]=s[j]s[i]=s[j] 或 j=0j=0 即可，
如果最终匹配成功（找到了 jj 使得 s[i]=s[j]s[i]=s[j]），那么 \pi(i)=j+1π(i)=j+1，否则 \pi(i)=0π(i)=0。<br>
注意在程序编写中，pi\[0]会直接被默认赋值为0。<br>
之后就可以基于暴力匹配法，进行改进，但字符判断结果为不同时，可以将字符的位置依据其进行改变，达到效率的提升。
